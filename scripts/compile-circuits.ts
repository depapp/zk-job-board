#!/usr/bin/env ts-node

/**
 * Circuit Compilation Script
 * Compiles Compact circuits to generate proving and verification keys
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Paths
const CIRCUITS_DIR = path.join(__dirname, '..', 'circuits');
const ARTIFACTS_DIR = path.join(__dirname, '..', 'artifacts', 'zk');
const CIRCUIT_FILE = path.join(CIRCUITS_DIR, 'job_eligibility.cmp');
const PARAMS_FILE = path.join(CIRCUITS_DIR, 'params.toml');

// Ensure artifacts directory exists
function ensureArtifactsDir() {
  if (!fs.existsSync(ARTIFACTS_DIR)) {
    fs.mkdirSync(ARTIFACTS_DIR, { recursive: true });
    console.log(`‚úÖ Created artifacts directory: ${ARTIFACTS_DIR}`);
  }
}

// Mock circuit compilation (simulates Midnight Compact compiler)
// In production, this would call the actual Midnight compiler
function compileCircuit() {
  console.log('üî® Compiling circuit...');
  
  // Read circuit file
  const circuitCode = fs.readFileSync(CIRCUIT_FILE, 'utf-8');
  console.log(`  üìÑ Read circuit from: ${CIRCUIT_FILE}`);
  
  // Read parameters
  const paramsContent = fs.readFileSync(PARAMS_FILE, 'utf-8');
  console.log(`  ‚öôÔ∏è  Read parameters from: ${PARAMS_FILE}`);
  
  // In production: Call Midnight Compact compiler
  // For now, we'll create mock artifacts
  
  // Generate mock proving key (in reality, this would be generated by trusted setup)
  const mockProvingKey = {
    type: 'proving_key',
    circuit: 'job_eligibility',
    version: '1.0.0',
    curve: 'BN254',
    scheme: 'groth16',
    constraints: 2048,
    publicInputs: 3,
    privateInputs: 42,
    // Mock key data (would be actual cryptographic material)
    alpha: generateMockPoint(),
    beta: generateMockPoint(),
    gamma: generateMockPoint(),
    delta: generateMockPoint(),
    ic: Array(4).fill(null).map(() => generateMockPoint()),
    h: Array(100).fill(null).map(() => generateMockPoint()),
    timestamp: new Date().toISOString()
  };
  
  // Generate mock verification key (derived from proving key)
  const mockVerificationKey = {
    type: 'verification_key',
    circuit: 'job_eligibility',
    version: '1.0.0',
    curve: 'BN254',
    scheme: 'groth16',
    publicInputs: 3,
    alpha: mockProvingKey.alpha,
    beta: mockProvingKey.beta,
    gamma: mockProvingKey.gamma,
    delta: mockProvingKey.delta,
    ic: mockProvingKey.ic.slice(0, 4),
    timestamp: new Date().toISOString()
  };
  
  // Generate metadata
  const metadata = {
    circuit: 'job_eligibility',
    version: '1.0.0',
    compiledAt: new Date().toISOString(),
    compiler: 'midnight-compact',
    compilerVersion: '1.0.0',
    hash: crypto.createHash('sha256').update(circuitCode).digest('hex'),
    constraints: {
      total: 2048,
      publicInputs: 3,
      privateInputs: 42,
      gates: 1500,
      wires: 4500
    },
    parameters: {
      N_SKILLS: 32,
      MAX_EXPERIENCE: 40,
      N_REGIONS: 6
    }
  };
  
  return { provingKey: mockProvingKey, verificationKey: mockVerificationKey, metadata };
}

// Generate mock elliptic curve point
function generateMockPoint() {
  return {
    x: '0x' + crypto.randomBytes(32).toString('hex'),
    y: '0x' + crypto.randomBytes(32).toString('hex')
  };
}

// Save artifacts to files
function saveArtifacts(artifacts: any) {
  console.log('üíæ Saving artifacts...');
  
  // Save proving key (normally would be large binary file)
  const pkPath = path.join(ARTIFACTS_DIR, 'job_eligibility.pk.json');
  fs.writeFileSync(pkPath, JSON.stringify(artifacts.provingKey, null, 2));
  console.log(`  ‚úÖ Proving key saved to: ${pkPath}`);
  
  // Save verification key
  const vkPath = path.join(ARTIFACTS_DIR, 'job_eligibility.vk.json');
  fs.writeFileSync(vkPath, JSON.stringify(artifacts.verificationKey, null, 2));
  console.log(`  ‚úÖ Verification key saved to: ${vkPath}`);
  
  // Save metadata
  const metaPath = path.join(ARTIFACTS_DIR, 'job_eligibility.meta.json');
  fs.writeFileSync(metaPath, JSON.stringify(artifacts.metadata, null, 2));
  console.log(`  ‚úÖ Metadata saved to: ${metaPath}`);
}

// Generate TypeScript types for the circuit
function generateTypes() {
  console.log('üìù Generating TypeScript types...');
  
  const typesContent = `// Auto-generated TypeScript types for job_eligibility circuit
// Generated at: ${new Date().toISOString()}

export interface PublicInputs {
  jobId: string;
  policyHash: string;
  nullifier: string;
}

export interface PrivateInputs {
  skillsBitset: boolean[];
  experienceYears: number;
  regionIndex: number;
  secret: string;
  requiredSkillsBitset: boolean[];
  minExperienceYears: number;
  allowedRegionsBitset: boolean[];
}

export interface ProofData {
  proof: {
    a: [string, string];
    b: [[string, string], [string, string]];
    c: [string, string];
  };
  publicInputs: PublicInputs;
}

export interface VerificationKey {
  alpha: { x: string; y: string };
  beta: { x: string; y: string };
  gamma: { x: string; y: string };
  delta: { x: string; y: string };
  ic: Array<{ x: string; y: string }>;
}

export const CIRCUIT_CONSTANTS = {
  N_SKILLS: 32,
  MAX_EXPERIENCE: 40,
  N_REGIONS: 6
} as const;
`;
  
  const typesPath = path.join(ARTIFACTS_DIR, 'circuit.types.ts');
  fs.writeFileSync(typesPath, typesContent);
  console.log(`  ‚úÖ TypeScript types saved to: ${typesPath}`);
}

// Main execution
async function main() {
  try {
    console.log('üöÄ Starting circuit compilation...\n');
    
    // Step 1: Ensure artifacts directory exists
    ensureArtifactsDir();
    
    // Step 2: Compile circuit
    const artifacts = compileCircuit();
    
    // Step 3: Save artifacts
    saveArtifacts(artifacts);
    
    // Step 4: Generate TypeScript types
    generateTypes();
    
    console.log('\n‚ú® Circuit compilation completed successfully!');
    console.log('üìä Summary:');
    console.log(`  - Constraints: ${artifacts.metadata.constraints.total}`);
    console.log(`  - Public inputs: ${artifacts.metadata.constraints.publicInputs}`);
    console.log(`  - Private inputs: ${artifacts.metadata.constraints.privateInputs}`);
    console.log(`  - Circuit hash: ${artifacts.metadata.hash.substring(0, 16)}...`);
    
  } catch (error) {
    console.error('‚ùå Circuit compilation failed:', error);
    process.exit(1);
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { compileCircuit, saveArtifacts, generateTypes };
